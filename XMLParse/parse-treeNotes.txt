file
pja 5/14/2020
walk an xml
def xmlFirst(mxml):
    """pu = getPU() from first"""
    tpu =mxml['KRID'][mxml['FIRST'].keys()[0]]['ATN']['pickup'].keys()[0]
    tkrid = mxml['ATN']['pickup'][tpu]['KRID'].keys()[0]
    return(tkrid)
#
-- 
tpu =mxml['KRID'][mxml['FIRST'].keys()[0]]['ATN']['pickup'].keys()[0]
tkrid = mxml['ATN']['pickup'][tpu]['KRID'].keys()[0]

def xmlNext(mxml,tpu): #=> krid/-1
    try:
        tpu = mxml['previousPU'][tpu]['ATN']['pickup'].keys()[0]
        tkrid = mxml['ATN']['pickup'][tpu]['KRID'].keys()[0]
        mxml['KRID'][tkrid]['ATN']
    except:
        tkrid = -1
    finally:
        nop = 1
    #endtry
    return(tkrid)
#






get cnx of first encounter
xmlKrid = xmlFirst(mxml)
xmlCNX = mxml['KRID'][xmlKrid]['ATN']['cnx'].keys()[0]

get xsd KRID via atn name = xmlCNX

xsdKRID = mxsd['ATN']['name'][xmlCNX]['KRID'].keys()[0]

get documentation 
xsdDocPU = mxsd['ENDCHAIN'][xsdKRID]['ENDNAME:PU']['documentation']
if len(xsdDocPU)==1 xsdDocPU = xsdDocPU.keys()[0]
else try mxsd['PICKUP'][xsdDocPU.keys()[0]]['KRID'] ok ix =0
     except ix = 1
     xsdDocPU = xsdDocPU.keys()[ix]
     
xsdDocKRID = mxsd['PICKUP'][xsdDocPU]['KRID'].keys()[0]
print(mxsd['KRID'][xsdDocKRID]['ATN']['value'].keys()[0])

{display other id types}

{display children KRIDS}
mxsd['ATN']['previousKRID']

not an input type move to next
nextXmlName = 
=======


pja 5/1/2020

i'm building a parse tree for xml using the xsd.
my use of xsd is sensitive to "<en" en name
if element, complex, sequence, choice , or none of the above

example 
mm = """<element name='contact'>
<complex>
<sequence>
<element name='fname' type='string' maxoccurs=1/>
<element name='lname' type='string' maxoccurs=1/>
<element name='phone' ref='phoneNumbers' minoccurs=0/>
</sequence>
</complex>
</element>"""

q - nesting conflict
can an xsd element have more than one child? unless that child is "complex"
yes <a><b>x</b><c>x</c> both b and c are children of a

ie can i parse <complex> to </complex> and know there is no nesting.
yes within a complexType there is no nesting. if a sequence needs a complex type it will ref call it


start:
mode = open
//init
parent=''
// modesw
;

modesw:
p1 -> t1! ...

